@startuml Schema to Data

skinparam shadowing false


start
note right: schemaToData(schema)
(A)
note right: let typedSchema = coerceTypes(schema)
(C)
note right: let conformedSchema = conformToType(typedSchema, undefined)
(D)
note right: let generatedData = generateData(conformedSchema)
:return generatedData;
stop


(A)
note right: coerceTypes(schema)

:let copy = shallow copy of schema;
:omit unsupported keywords from copy;

if (schema.type?) then (string)
  :copy.type = [schema.type];
elseif (schema.type?) then (nonempty array)
  :copy.type = schema.type;
elseif (schema.type?) then (undefined)
  :copy.type = ['null', 'string', 'number', 'boolean', 'array', 'object'];
else
  :error;
  note right
    - json-schema specifies "type"
    as a string or array of strings
    - ajv does not allow
    an empty type array
  end note
  stop
endif

:omit keywords from copy
that do not apply to copy.type;

if (schema has allOf?) then (yes)
  (A)
  note right:copy.allOf = map(schema.allOf, coerceTypes);
  :filter copy.type
  where type is in every
  subschema.type in allOf;
  (B)
  note right: validate copy.type
else (no)
endif

if (schema has anyOf?) then (yes)
  (A)
  note right:copy.anyOf = map(schema.anyOf, coerceTypes);
  :filter copy.type
  where type is in at least one
  subschema.type in anyOf;
  (B)
  note right: validate copy.type
else (no)
endif

if (schema has oneOf?) then (yes)
  (A)
  note right:copy.oneOf = map(schema.oneOf, coerceTypes)
  :filter copy.type
  where type is in at least one
  subschema.type in oneOf;
  (B)
  note right: validate copy.type
else (no)
endif

if (schema has not?) then (yes)
  (A)
  note right:copy.not = coerceTypes(schema.not);
  if (copy.not only has type keyword?) then (yes)
  :filter copy.type
    where type is not in copy.not.type;
    (B)
  note right: validate copy.type
  else (no)
  endif
else (no)
endif

:return copy;
detach


(B)
note right: validate copy.type
if (copy.type is empty?) then (yes)
  :error;
  stop
else (no)
endif
:continue;
detach


(C)
note right: conformToType(schema, type)
if (type is undefined?) then (yes)
  :type = sample(schema.type);
else (no)
endif
:let copy = shallow copy of schema;
:copy.type = type;
:omit keywords from copy that do not apply
to type;
while (foreach subschema of copy[allOf|anyOf|oneOf])
  (C)
  note right:conformToType(subschema, type)
endwhile
while (foreach subschema in copy)
  (C)
  note right:copy[subschemaPath] = conformToType(subschema)
endwhile
:consolidate rules from all allOf, anyOf, oneOf;
note right: needs the rest of the owl
:return copy;
detach


(D)
note right: generateData(schema)
if (type?) then (primitive)
  :generate data based on validation constraints;
elseif (type?) then (array)
  :determine if tuple or list
  and traverse items;
else (object)
  :traverse properties;
endif
:return generated data;
detach


@enduml
